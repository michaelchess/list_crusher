#!/usr/bin/env python
'''
list_crusher3.py is vastly different from the earlier versions of list_crusher
in terms of how it works. The purpose remains the same: to evaluate the overlap
between a list of de novo loss of function (LoF) variants and a given input
gene list. 

Unlike earlier incarnations, this version does not rely on long lists of
simulated de novo events. It uses the per gene probabilites of mutation
generated by the mutational model. First, it determines the total probability
of a LoF mutation for the genes on the input list. This is compared against
the probability of a LoF mutation for all genes to figure out the expected
percentage of LoF on the input list. That percentage is used in a binomial to
determine the tail probability of seeing the observed overlap or more.

REQUIRES THAT R BE LOADED.

Version 3.1 updated so it is pbinom(n-1,x,y) instead of pbinom(n,x,y)
Version 3.2 updated list_comparison so that it keeps genes with multiple
mutations (the set() function got rid of counts and kept unique variables)
Version 3.3 updated so that de novo mutations in genes for which a probability
could not be found are not counted
Version 3.4 updated so that it could analyze mut_prob_fs_adjdepdiv.txt (as
opposed to adj_fs_pred_by_depth.txt)
Version 3.5 updated to print the actual overlap

'''

__version__ = 3.5
__author__ = "Kaitlin E. Samocha <ksamocha@fas.harvard.edu>"
__date__ = "July 11th, 2013"

import sys
import os.path
import argparse
from rpy2.robjects.packages import importr


def store_input_gene_list(list1):
    'Store the genes on the list of interest'
    genes = []

    with open(list1, 'r') as file1:
        for line in file1:
            line = line.split()
            genes.append(line[0]) # gene name should be first column

    return genes


def store_dn_mutations(list2):
    'Store the de novo mutations by mutation type'
    lof = []
    mis = []
    syn = []

    with open(list2, 'r') as file2:
        for line in file2:
            line = line.split()
            gene = line[0]
            mut = line[1]

            if mut in ('nonsense', 'NONSENSE', 'Nonsense', 'splice',
                       'Splice', 'splice_indel', 'SPLICE',
                       'frameshift', 'frame-shift', 'Frameshift',
                       'FRAMESHIFT'):
                lof.append(gene)
            elif mut in ('missense', 'missense_0', 'missense_1',
                         'missense_2', 'missense_3', 'Missense',
                         'MISSENSE'):
                mis.append(gene)
            elif mut in ('silent', 'synonymous', 'SILENT',
                         'SYNONYMOUS'):
                syn.append(gene)
            else:
                continue

    return (lof, mis, syn)


def list_comparison(list1, list2, not_found):
    'Compares the genes on two lists and returns a count of number overlapping'
    counter = 0
    overlap = []

    for gene in list1:
        if gene in list2:
            if gene in not_found:
                continue
            else:
                counter += 1
                overlap.append(gene)
    
    return (counter, overlap)


def add_prob(current_total, prob):
    'Add the probability to the current total and return'

    if prob == 'NA':
        new_total = current_total
    else:
        new_total = current_total + 10**(float(prob))

    return new_total

def find_mut_prob(prob_file, gene_list):
    'Find the probabilities of mutation for the list of interest by mut type'
    lof_list = 0.0
    lof_total = 0.0
    mis_list = 0.0
    mis_total = 0.0
    syn_list = 0.0
    syn_total = 0.0
    seen_genes = []
    not_found = []

    with open(prob_file, 'r') as probs:
        for entry in probs:
            if entry.startswith('gene') or entry.startswith('transcript'):
                continue

            entry = entry.split()
            gene = entry[1]

            lof_total = add_prob(lof_total, entry[7]) # nonsense
            lof_total = add_prob(lof_total, entry[9]) # splice
            lof_total = add_prob(lof_total, entry[10]) # frameshift ## changed from 11

            mis_total = add_prob(mis_total, entry[6])
            syn_total = add_prob(syn_total, entry[5])

            if gene in gene_list:
                lof_list = add_prob(lof_list, entry[7])
                lof_list = add_prob(lof_list, entry[9])
                lof_list = add_prob(lof_list, entry[10]) ## changed from 11
                mis_list = add_prob(mis_list, entry[6])
                syn_list = add_prob(syn_list, entry[5])

                seen_genes.append(gene)
    returnString = ''
    if len(seen_genes) != len(gene_list):
        for item in gene_list:
            if item not in seen_genes:
                not_found.append(item)

        returnString+='Could not find probabilities for these genes:\n'
        returnString+='{0}\n'.format('\n'.join(not_found))

    return (lof_list, lof_total, mis_list, mis_total, syn_list, syn_total,
            not_found, returnString)


def main(preds, dnm, loi):
    'Run subfunctions'
    # Storing input and de novo gene lists
    interest_list = store_input_gene_list(loi)
    (dn_lof, dn_mis, dn_syn) = store_dn_mutations(dnm)
    # Extracting probabilities of mutation
    (p_lof_list, p_lof_total,
     p_mis_list, p_mis_total,
     p_syn_list, p_syn_total,
     not_found_genes, returnString) = find_mut_prob(preds, interest_list)

    # Determine overlap between de novo list and input list
    (lof_overlap, lof_overlap_list) = list_comparison(dn_lof, interest_list,
                                                      not_found_genes)
    (mis_overlap, mis_overlap_list) = list_comparison(dn_mis, interest_list,
                                                      not_found_genes)
    (syn_overlap, syn_overlap_list) = list_comparison(dn_syn, interest_list,
                                                      not_found_genes)

    # Determine expected percentage of overlap
    exp_per_lof = (p_lof_list/p_lof_total)
    exp_per_mis = (p_mis_list/p_mis_total)
    exp_per_syn = (p_syn_list/p_syn_total)

    # Evaluate signicance of overlap
    lof_num = len(dn_lof)
    mis_num = len(dn_mis)
    syn_num = len(dn_syn)

    stats = importr('stats')
    p_lof = stats.pbinom(lof_overlap-1, lof_num, exp_per_lof, lower=False)[0]
    p_mis = stats.pbinom(mis_overlap-1, mis_num, exp_per_mis, lower=False)[0]
    p_syn = stats.pbinom(syn_overlap-1, syn_num, exp_per_syn, lower=False)[0]
    
    # pbinom(observed_overlap-1, num_trials, expectation)

    # Determines fold enrichment, only printed with -p
    fold_lof = (float(lof_overlap)/lof_num) / exp_per_lof
    fold_mis = (float(mis_overlap)/mis_num) / exp_per_mis
    fold_syn = (float(syn_overlap)/syn_num) / exp_per_syn

    # Print results
    returnString+='Significance for LoF overlap: {0}'.format(p_lof)
    returnString+='\n'
    #if print_overlap:
    returnString+='\t{0} overlapping LoF mutations: {1}'.format(lof_overlap, ', '.join(lof_overlap_list))
    returnString+='\n'
    returnString+='\tExpected overlap: {0}'.format(exp_per_lof)
    returnString+='\n'
    returnString+='\tActual LoF overlap: {0}'.format(float(lof_overlap)/lof_num)
    returnString+='\n'
    returnString+='\tFold enrichment: {0}'.format(fold_lof)
    returnString+='\n'

    returnString+='Significance for missense overlap: {0}'.format(p_mis)
    returnString+='\n'
    #if print_overlap:
    returnString+='\t{0} overlapping missense mutations: {1}'.format(mis_overlap, ', '.join(mis_overlap_list))
    returnString+='\n'
    returnString+='\tExpected overlap: {0}'.format(exp_per_mis)
    returnString+='\n'
    returnString+='\tActual missense overlap: {0}'.format(float(mis_overlap)/mis_num)
    returnString+='\n'
    returnString+='\tFold enrichment: {0}'.format(fold_mis)
    returnString+='\n'

    returnString+='Significance for synonymous overlap: {0}'.format(p_syn)
    returnString+='\n'
    #if print_overlap:
    returnString+='\t{0} overlapping synonymous mutations: {1}'.format(syn_overlap, ', '.join(syn_overlap_list))
    returnString+='\n'
    returnString+='\tExpected overlap: {0}'.format(exp_per_syn)
    returnString+='\n'
    returnString+='\tActual synonymous overlap: {0}'.format(float(syn_overlap)/syn_num)
    returnString+='\n'
    returnString+='\tFold enrichment: {0}'.format(fold_syn)
    returnString+='\n'
    return returnString

'''
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=
       # Determine the significance of the de novo overlap with an
        #input list of genes
    )
    parser.add_argument('preds', action='store', type=str,
                        help='File with gene probabilities of mutation')
    parser.add_argument('dnm', action='store', type=str,
                        help='List of de novo mutations')
    parser.add_argument('loi', action='store', type=str,
                        help='Input list of interest')
    parser.add_argument('-p', '--print_overlap', action='store_true',
                        dest='print_overlap', help='Print overlapping genes')
        
    args = parser.parse_args()
    
    if not os.path.exists(preds):
        sys.exit('{0}: No such file or directory'.format(preds))
    if not os.path.exists(dnm):
        sys.exit('{0}: No such file or directory'.format(dnm))
    if not os.path.exists(loi):
        sys.exit('{0}: No such file or directory'.format(loi))

    main(args)'''
